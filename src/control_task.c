/*
 * control_task.c
 *
 *  Created on: Jun 9, 2017
 *      Author: xwu
 */
//****************User guide****************************************************
//This multi-task frame is suitable for multi-task software based on Free-RTOS
//In order to use the frame, user have to make changes to the control_task.c,
//control_task.h, application_taskN.c files
//the guide for modifying application_taskN.c file is wrote in application_task.h
//file
//before modifying, you need to decide how many application_taskN.c files you need
//for your program. Then make them seperate names and created in the main.c files.
//here is the guide of modifing in control task and user main function
//step1:
//include needed header files for your main.c file to use Free-RTOS
//and put control_task.c file and those application_taskN.c files in the source path
//of your project
//example:
//#include "control_task.h"
//#include "application_task.h"
//step2:
//declear the control_task and other application_taskN in main.c file
//example:
//void control_task( void *pvParameters );
//void application_taskN( void *pvParameters );
//N can be any number according to how many application tasks user need
//
//step3:
//create tasks using osi_TaskCreate with corresponding task name and label
//control task priority as 2, application tasks hold priority 1.
//example:
//osi_TaskCreate( control_task, "TASK1",OSI_STACK_SIZE, NULL, 2, NULL );
//osi_TaskCreate( application_taskN, "TASKN",OSI_STACK_SIZE,NULL, 1, NULL );
//
//step4:
//use osi_start() to start task scheduler in your main.c file
//till now you finished your main.c file modifying
//
//modifying control_task:
//step1:
//include needed header files for customer mission for the control_task to do
//when control_task receive its data
//step2:
//change the number of task and control task ID according to user in contro_task.h
//file
//step3:
//add customer variable in customer variable area
//initialize customer variable in customer variable initialization area
//add needed code in customer codes area for certain mission
//till here modifying for control_task.c and its header file done
//******************************************************************************
//tips:
//please make sure the application tasks' name are consistent within each
//application_taskN.c file
//you can have as many application_taskN.file as you want, but they need separate
//name to be recognized by the program
//******************************************************************************

#include "control_task.h"

// Standard includes.
#include <stdio.h>
#include <stdlib.h>


#include "osi.h"
#include "string.h"
// Driverlib includes
#include "hw_memmap.h"
#include "hw_common_reg.h"
#include "hw_types.h"
#include "hw_ints.h"
#include "interrupt.h"
#include "rom.h"
#include "rom_map.h"
#include "uart.h"
#include "prcm.h"
#include "utils.h"
#include "pin.h"

// Common interface includes
#include "uart_if.h"
#include "UARTnew.h"
#include "i2cnew.h"
#include "i2c_if.h"
#include "timer_control.h"
#include "gpio.h"
#include "gpio_if.h"
#include "command.h"


CONTROL_HANDLE_t controlHandle;
/***************************************************
 * setter of the controlHandle
 * ************************************************/
void setControlHandle(CONTROL_HANDLE_t taskHandle){
	controlHandle = taskHandle;
}

/***************************************************
 * control task
 * ************************************************/
void control_task(){
	DATA_HANDLE_t controlDataHandle;


//initialize array and check result
	uint8_t tempbuff[] = "Control task is processing command and data for itself\n";

	SendControlData_S_initial();

while(1){

	//DE-Queue
	xQueueReceive( controlHandle->ControlTaskQ, &controlDataHandle, portMAX_DELAY );
	//command and data must be those for control task

		//processing command
		//here for test using UARTwrite to show program passed here
		//********************************test**************

		//using uart_task to print it
		//allocate new memory to hold new dataout

	SendControlData(UARTPRINT, sizeof(tempbuff), tempbuff);

	free(controlDataHandle->dataBuffer);
	free(controlDataHandle);

}

}

/**************************************
 *Transfer data generated by this application task to
 * control task called by other application tasks or itself
 *
 * @para controlCommand
 * the new 16 bits command
 * @para dataSize
 * the new 16 bits data size
 * @para dataBuffer
 * the pointer to the new data buffer of 8 bits data unit
 *
 * precondition:
 * dataBuffer is mallocated space with dataSize
 * system has enough memory space to hold data to be sent
 *
 * postcondition:
 * memory allocated, it will be freed by target task
 ***************************************/
int32_t SendControlData(uint16_t controlCommand, uint16_t dataSize, uint8_t* dataBuffer){
	xSemaphoreTake( controlHandle->SendControlData_Semaphore, portMAX_DELAY ); //lock function

	controlHandle->task_ID = (controlCommand >> 8);

	if(controlHandle->task_ID == CONTROLTASKID){

		  //allocate memory fore enQueue
		  DATA_HANDLE_t controlDataHandle = (DATA_HANDLE_t)malloc(sizeof(DATA_STATE_t));
		  //check memory allocation result
		  if(controlDataHandle == NULL){
			  return MEMORYALOCATIONFAILED;
		  }

		  controlDataHandle->controlCommand = controlCommand;
		  controlDataHandle->dataSize = dataSize;
		  controlDataHandle->dataBuffer = (uint8_t *)malloc(controlDataHandle->dataSize * sizeof(uint8_t));
		  //check memory allocation result
		  if(controlDataHandle->dataBuffer == NULL){
			  free(controlDataHandle);
			  return MEMORYALOCATIONFAILED;
		  }

		  memcpy(controlDataHandle->dataBuffer, dataBuffer, controlDataHandle->dataSize);

			//enQueue
		  osi_MsgQWrite(&controlHandle->ControlTaskQ, (void *) &controlDataHandle, 0); // 0 configure no waitting time
			// or this form:
			// xQueueSend( TASK1Q, pData, ( TickType_t ) 0 );
		  xSemaphoreGive( controlHandle->SendControlData_Semaphore );// unlock function, sequential lock for one task using at one moment

		  return SUCCESS;
	}else{

		for(controlHandle->loopIndex = 0; controlHandle->loopIndex < TASKNUMBER; (controlHandle->loopIndex)++){
		//if TASKID encoded in input controlCommand meets the TASKID stored in
		//structure in the taskList
		//remember i and break the loop
			if(((uint8_t)(controlCommand >> 8)) == controlHandle->taskList[controlHandle->loopIndex].taskID){ //first part may have bugs
				break;
			}
		}

		//call function stored in structure in taskList[i]

		SetCommandToTask(controlHandle->taskList[controlHandle->loopIndex].taskQ, controlCommand, dataSize, dataBuffer);

		//return
		xSemaphoreGive( controlHandle->SendControlData_Semaphore );// unlock function, sequential lock for one task using at one moment

		if(controlHandle->loopIndex >= TASKNUMBER ){
			return NOMATCH;
		}else{
			return SUCCESS;
		}
	}



}

/***************************************************
 * called by other tasks to register itself to the control list
 * @para taskID
 * other task's 16 bits ID
 * @para pfnSetCommandToTask
 * other task's SetCommandToTaskN function label
 * ************************************************/
int32_t registerTaskToControl(uint8_t taskID, OsiMsgQ_t taskQ){
	controlHandle->taskList[controlHandle->listIndex].taskID = taskID;
	controlHandle->taskList[controlHandle->listIndex].taskQ = taskQ;
	controlHandle->listIndex = controlHandle->listIndex + 1;
	if(controlHandle->listIndex > TASKNUMBER){
		return OUTOFLIST;
	}else{
		return SUCCESS;
	}
}
/***************************************************
 * called by other tasks or itself to send data using queue
 * @para TaskQ
 * The Queue of that task
 * @para controlCommand
 * new command to send
 * @para dataSize
 * new dataSize to send
 * @para dataBuffer
 * new dataBuffer to send
 * @return
 * return error check value
 * ************************************************/
int32_t SetCommandToTask(OsiMsgQ_t TaskQ, uint16_t controlCommand, uint16_t dataSize, uint8_t* dataBuffer){


  //allocate memory fore enQueue
	DATA_HANDLE_t apptaskhandle = (DATA_HANDLE_t)malloc(sizeof(DATA_STATE_t));
  //check memory allocation result
  if(apptaskhandle == NULL){
	  return MEMORYALOCATIONFAILED;
  }

  apptaskhandle->controlCommand = controlCommand;
  apptaskhandle->dataSize = dataSize;
  apptaskhandle->dataBuffer = (uint8_t *)malloc(apptaskhandle->dataSize * sizeof(uint8_t));
  //check memory allocation result
  if(apptaskhandle->dataBuffer == NULL){
	  free(apptaskhandle);
	  return MEMORYALOCATIONFAILED;
  }

  memcpy(apptaskhandle->dataBuffer, dataBuffer, apptaskhandle->dataSize);

	//enQueue
  osi_MsgQWrite(&TaskQ, (void *) &apptaskhandle, 0); // 0 configure no waitting time
	// or this form:
	// xQueueSend( TASK2Q, pData, ( TickType_t ) 0 );

  return SUCCESS;
}

/***************************************************
 * create a protecting semaphore
 * the semaphore is used to protect the multi-entering
 * of SendControlData function area
 * ************************************************/
int32_t SendControlData_S_initial(){
	vSemaphoreCreateBinary( controlHandle->SendControlData_Semaphore ); //semaphore create
	if(controlHandle->SendControlData_Semaphore == NULL)
		return ERROR;
	else
		return SUCCESS;
}

/***************************************************
 * initialize control_task
 * the step is necessary for initializing application tasks
 *
 * @return
 * Handle to control_task data field
 * ************************************************/
CONTROL_HANDLE_t initialControlTask(){
	CONTROL_HANDLE_t taskHandle;
	taskHandle = (CONTROL_HANDLE_t)malloc(sizeof(CONTROL_STATE_t));
	taskHandle->task_ID = CONTROLTASKID;
	taskHandle->ControlTaskQ = taskQCreat(taskHandle->ControlTaskQ);
	taskHandle->listIndex = 0;
	return taskHandle;
}

/***************************************************
 *initialize a application task
 *precondition:
 *the function must be called after control_task is initialized
 *
 *@para TASKID
 *the task ID of the certain application task
 *@return
 *return the handle to the application task data field
 * ************************************************/
TASK_HANDLE_t initialAppTask(uint8_t TASKID){
	TASK_HANDLE_t taskHandle;
	taskHandle = (TASK_HANDLE_t)malloc(sizeof(TASK_STATE_t));
	taskHandle->taskID = TASKID;
	taskHandle->TASKQ = taskQCreat(taskHandle->TASKQ);
	registerTaskToControl(taskHandle->taskID, taskHandle->TASKQ);

	return taskHandle;
}
/***************************************************
 * create Queue and return
 * precondition:
 * Queue belonging task field must be constructed before
 *
 * @para TASKQ
 * the Queue variable in each task's data field
 * @return
 * return the reference to the created Queue of input variable
 * ************************************************/
OsiMsgQ_t taskQCreat(OsiMsgQ_t TASKQ){
	OsiReturnVal_e osi_retVal;
		osi_retVal = osi_MsgQCreate(&TASKQ, "TASKQ", MAX_MSG_LENGTH, MAX_MSG_NUMBER);
			if(osi_retVal != OSI_OK)
		    {
				// Queue was not created and must not be used.
		        while(1);
		    }

			return TASKQ;
}

/*************************************************
* This method is used to monitor the control stop commend during the operating mode
* usually be put in the inside task mission loop (like keeping measure data for certain time loop)
* once message on task's Queue, peek the first element in Queue
* if the first commend sent is a stop, then stop the current mission
* and the task will be return to the Queue receive step to receive next commend
*
* When want to let the application task quit the current command and execute a new command
* must send a TASKID||STOP command (defined in command.h) first
* and then send the new command user want
*/
int32_t CurrentCommendStop(TASK_HANDLE_t TASKHANDLE){
    DATA_HANDLE_t checkHandle;
    if(uxQueueMessagesWaiting( TASKHANDLE->TASKQ ) != 0 ){
        xQueuePeek( TASKHANDLE->TASKQ, &checkHandle, portMAX_DELAY );
        if(checkHandle->controlCommand == TASKHANDLE->taskID || STOP){
        	//*************customer code area******************
        	//method to stop the current mission
        	//example:
        	//like force a loop to break
        	//
        	//method to clear up the current mission
        	//example:
        	//free allocated memory
        	//stop timer and other interfaces
        	//*************************************************
        	free(checkHandle->dataBuffer);
        	free(checkHandle); // free memory space if only the commend is a stop commend

        	return SUCCESS;
        }else{
        	return NOMATCH;
        }
    }else{
    	return NOMATCH;
    }
}

